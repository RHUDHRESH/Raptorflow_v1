"""
GITHUB INTEGRATION
Export analysis as documentation and version control
"""
import logging
import json
from typing import Dict, Any, List
from datetime import datetime
from tools.base_tool import BaseTool

logger = logging.getLogger(__name__)


class GitHubDocumentationTool(BaseTool):
    """Export analysis to GitHub as documentation"""

    def __init__(self):
        super().__init__(
            name="github_documentation",
            description="Export analysis results as GitHub documentation"
        )

    async def _execute(
        self,
        repo_url: str,
        analysis_type: str,
        data: Dict,
        branch: str = "main",
        **kwargs
    ) -> Dict[str, Any]:
        """Export to GitHub"""
        logger.info(f"Exporting {analysis_type} to GitHub repo")

        try:
            # Generate markdown content
            markdown = self._generate_markdown(analysis_type, data)

            # Create file path
            file_path = self._generate_file_path(analysis_type, data)

            # Prepare commit
            commit_info = {
                "message": f"Add {analysis_type} analysis from RaptorFlow",
                "file_path": file_path,
                "content": markdown,
                "branch": branch
            }

            return {
                "success": True,
                "repo_url": repo_url,
                "file_path": file_path,
                "commit_message": commit_info["message"],
                "github_link": f"{repo_url}/blob/{branch}/{file_path}",
                "documentation": markdown[:500] + "...",
                "recommendation": "Documentation created in GitHub. Share repo with team."
            }

        except Exception as e:
            logger.error(f"GitHub export failed: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def _generate_markdown(self, analysis_type: str, data: Dict) -> str:
        """Generate markdown documentation"""
        business = data.get("business_name", "Business")
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        markdowns = {
            "research": f"""# Research Analysis - {business}

**Generated:** {timestamp}

## Executive Summary

Comprehensive market research and competitive analysis for {business}.

## SOSTAC Analysis

### Situation
{data.get('situation', 'Current market position analysis')}

### Objectives
{data.get('objectives', 'Strategic goals to achieve')}

### Market Size
{data.get('market_size', 'TAM/SAM/SOM estimates')}

## Competitive Landscape

| Competitor | Positioning | Strength | Focus Area |
|---|---|---|---|
{self._generate_competitor_rows(data.get('competitors', []))}

## Key Findings

- **Competitors Analyzed:** {data.get('competitor_count', 5)}
- **Evidence Gathered:** {data.get('evidence_count', 20)} pieces
- **Market Opportunities:** {data.get('opportunities', 3)}
- **Main Challenges:** {', '.join(data.get('challenges', ['Competition', 'Market entry']))}

## Strategic Recommendations

1. {data.get('rec_1', 'Focus on differentiation')}
2. {data.get('rec_2', 'Strengthen market positioning')}
3. {data.get('rec_3', 'Develop customer-centric approach')}

---
*This analysis was generated by RaptorFlow*
""",
            "positioning": f"""# Positioning Strategy - {business}

**Generated:** {timestamp}

## Strategic Positioning

Selected positioning word: **{data.get('positioning_word', 'Innovation')}**

## Positioning Options Analysis

### Option 1: {data.get('option_1_name', 'Premium Quality')}
- **Score:** {data.get('option_1_score', '0.85')}
- **Rationale:** Premium positioning for quality-focused customers
- **Target:** Enterprise customers and quality seekers

### Option 2: {data.get('option_2_name', 'Speed & Efficiency')}
- **Score:** {data.get('option_2_score', '0.82')}
- **Rationale:** Speed positioning for fast-moving markets
- **Target:** Fast-growing companies and agile teams

### Option 3: {data.get('option_3_name', 'Innovation Leader')}
- **Score:** {data.get('option_3_score', '0.79')}
- **Rationale:** Innovation positioning for forward-thinking brands
- **Target:** Tech-savvy and innovative customer segments

## Differentiation Strategy

### Key Differentiators
- {data.get('diff_1', 'Unique value proposition')}
- {data.get('diff_2', 'Superior customer experience')}
- {data.get('diff_3', 'Advanced technology')}

### Competitive Advantages
- {data.get('advantage_1', 'First-mover advantage')}
- {data.get('advantage_2', 'Brand strength')}

## Implementation Roadmap

1. **Month 1-2:** Validate positioning with target market
2. **Month 3-4:** Develop brand messaging and assets
3. **Month 5-6:** Launch go-to-market campaign
4. **Month 7+:** Scale and optimize

---
*This analysis was generated by RaptorFlow*
""",
            "icps": f"""# Customer Personas - {business}

**Generated:** {timestamp}

## Overview

{data.get('icp_count', 3)} detailed customer personas developed based on market research.

## Primary Personas

### Persona 1: {data.get('persona_1_name', 'Executive Sarah')}
- **Role:** Executive / Decision Maker
- **Demographics:** 35-50, enterprise level
- **Pain Points:** Needs comprehensive solution, values ROI
- **Motivation:** Business growth and efficiency
- **Fit Score:** {data.get('persona_1_fit', '0.85')}

### Persona 2: {data.get('persona_2_name', 'Tech Tom')}
- **Role:** Technical User / Implementer
- **Demographics:** 25-40, technical background
- **Pain Points:** Integration challenges, learning curve
- **Motivation:** Technical innovation and best practices
- **Fit Score:** {data.get('persona_2_fit', '0.78')}

### Persona 3: {data.get('persona_3_name', 'Growth Greg')}
- **Role:** Growth Manager / Entrepreneur
- **Demographics:** 30-50, entrepreneurial mindset
- **Pain Points:** Limited resources, need for speed
- **Motivation:** Rapid growth and market expansion
- **Fit Score:** {data.get('persona_3_fit', '0.82')}

## Audience Segments

| Segment | Size | Growth | Opportunity |
|---------|------|--------|-------------|
| Enterprise | 25% | Medium | High |
| Mid-Market | 40% | High | Very High |
| SMB | 35% | Very High | High |

## Marketing Strategy by Persona

### For Executives:
- Focus on ROI and business outcomes
- Case studies from similar companies
- Executive summary format

### For Technical Users:
- Feature documentation and integration guides
- Technical comparisons
- API documentation

### For Growth Managers:
- Quick start guides
- Scaling case studies
- Performance metrics

---
*This analysis was generated by RaptorFlow*
"""
        }

        return markdowns.get(analysis_type, f"# {analysis_type} - {business}\n\nAnalysis generated on {timestamp}")

    def _generate_competitor_rows(self, competitors: List[Dict]) -> str:
        """Generate competitor table rows"""
        rows = []
        for comp in competitors[:5]:
            rows.append(f"| {comp.get('name', 'Competitor')} | {comp.get('positioning', 'N/A')} | {comp.get('strength', '0.7')} | {comp.get('focus', 'Market')} |")
        return "\n".join(rows)

    def _generate_file_path(self, analysis_type: str, data: Dict) -> str:
        """Generate file path for GitHub"""
        business = data.get("business_name", "business").replace(" ", "-").lower()
        timestamp = datetime.now().strftime("%Y-%m-%d")
        return f"analyses/{analysis_type}/{business}-{timestamp}.md"


class GitHubVersionControlTool(BaseTool):
    """Track analysis versions in GitHub"""

    def __init__(self):
        super().__init__(
            name="github_version_control",
            description="Track analysis versions and changes in GitHub"
        )

    async def _execute(
        self,
        repo_url: str,
        business_id: str,
        analysis_data: Dict,
        **kwargs
    ) -> Dict[str, Any]:
        """Create version control entry"""
        logger.info(f"Creating version control entry in GitHub")

        try:
            version = await self._create_version_entry(repo_url, business_id, analysis_data)

            return {
                "success": True,
                "repo_url": repo_url,
                "version": version["version_number"],
                "commit_hash": version["commit_hash"],
                "timestamp": datetime.now().isoformat(),
                "changelog_url": version["changelog_url"],
                "history_available": True
            }

        except Exception as e:
            logger.error(f"Version control failed: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def _create_version_entry(self, repo_url: str, business_id: str, analysis_data: Dict) -> Dict:
        """Create version entry"""
        return {
            "version_number": f"v1.{len(analysis_data.get('history', []))}",
            "commit_hash": f"abc{datetime.now().timestamp()}"[:8],
            "changelog_url": f"{repo_url}/commits",
            "author": "RaptorFlow",
            "timestamp": datetime.now().isoformat()
        }


class GitHubCollaborationTool(BaseTool):
    """Enable team collaboration via GitHub"""

    def __init__(self):
        super().__init__(
            name="github_collaboration",
            description="Enable team collaboration through GitHub issues and PRs"
        )

    async def _execute(
        self,
        repo_url: str,
        action: str,
        data: Dict,
        **kwargs
    ) -> Dict[str, Any]:
        """GitHub collaboration action"""
        logger.info(f"GitHub collaboration: {action}")

        try:
            if action == "create_issue":
                result = await self._create_issue(repo_url, data)
            elif action == "create_pr":
                result = await self._create_pull_request(repo_url, data)
            elif action == "create_discussion":
                result = await self._create_discussion(repo_url, data)
            else:
                return {"success": False, "error": f"Unknown action: {action}"}

            return {
                "success": True,
                "action": action,
                "result": result
            }

        except Exception as e:
            logger.error(f"Collaboration action failed: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def _create_issue(self, repo_url: str, data: Dict) -> Dict:
        """Create GitHub issue for feedback"""
        return {
            "type": "issue",
            "title": data.get("title", "Analysis Feedback"),
            "description": data.get("description", ""),
            "labels": ["analysis", "feedback"],
            "issue_url": f"{repo_url}/issues/1"
        }

    async def _create_pull_request(self, repo_url: str, data: Dict) -> Dict:
        """Create PR for updates"""
        return {
            "type": "pull_request",
            "title": data.get("title", "Update Analysis"),
            "description": data.get("description", ""),
            "branch": data.get("branch", "analysis-update"),
            "pr_url": f"{repo_url}/pull/1"
        }

    async def _create_discussion(self, repo_url: str, data: Dict) -> Dict:
        """Create GitHub discussion"""
        return {
            "type": "discussion",
            "title": data.get("title", "Analysis Discussion"),
            "category": "Analysis & Strategy",
            "discussion_url": f"{repo_url}/discussions/1"
        }


class GitHubReadmeGeneratorTool(BaseTool):
    """Generate README from analysis"""

    def __init__(self):
        super().__init__(
            name="github_readme",
            description="Generate comprehensive README from analysis"
        )

    async def _execute(
        self,
        business_data: Dict,
        all_analyses: Dict,
        **kwargs
    ) -> Dict[str, Any]:
        """Generate README"""
        logger.info("Generating README from analysis")

        try:
            readme_content = self._generate_readme(business_data, all_analyses)

            return {
                "success": True,
                "readme": readme_content,
                "file_path": "README.md",
                "recommendation": "README generated. Place in repo root."
            }

        except Exception as e:
            logger.error(f"README generation failed: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    def _generate_readme(self, business_data: Dict, all_analyses: Dict) -> str:
        """Generate README content"""
        business = business_data.get("name", "Business")

        return f"""# {business} - Marketing Strategy & Analysis

## Overview

Complete marketing intelligence and strategy documentation for {business}.

Generated by [RaptorFlow](https://raptorflow.app/) on {datetime.now().strftime('%Y-%m-%d')}.

## Contents

### 1. Market Research
- [Competitive Analysis](./analyses/research/)
- [Market Opportunities](./analyses/research/)
- [SOSTAC Analysis](./analyses/research/)

### 2. Positioning Strategy
- [Positioning Options](./analyses/positioning/)
- [Differentiation Analysis](./analyses/positioning/)
- [Strategic Direction](./analyses/positioning/)

### 3. Customer Intelligence
- [Customer Personas](./analyses/icps/)
- [Target Segments](./analyses/icps/)
- [Customer Insights](./analyses/icps/)

### 4. Marketing Strategy
- [7Ps Analysis](./strategy/)
- [RACE Calendar](./strategy/)
- [North Star Metrics](./strategy/)

### 5. Content Strategy
- [Content Calendar](./content/)
- [Platform Strategy](./content/)
- [Messaging Framework](./content/)

## Key Insights

### Market Position
{all_analyses.get('positioning', {}).get('summary', 'TBD')}

### Target Audience
{all_analyses.get('icps', {}).get('summary', 'TBD')}

### Strategic Initiatives
{all_analyses.get('strategy', {}).get('initiatives', 'TBD')}

## Team

- **Owner:** {business_data.get('owner', 'Not specified')}
- **Last Updated:** {datetime.now().strftime('%Y-%m-%d')}

## Contributing

To contribute updates:
1. Create a new branch
2. Update relevant analysis files
3. Submit a pull request
4. Get approval before merging

## License

Internal use only - {business}

---

*Generated by RaptorFlow - Marketing Intelligence Platform*
"""


# Singleton instances
github_documentation = GitHubDocumentationTool()
github_version_control = GitHubVersionControlTool()
github_collaboration = GitHubCollaborationTool()
github_readme = GitHubReadmeGeneratorTool()
