"""ICPBuilderAgent - Generates Ideal Customer Profiles from context and JTBD"""
import logging
import json
import uuid
from typing import Dict, Any, Optional, List
from datetime import datetime
from ..core.service_factories import ServiceManager
from ..base_agent import BaseAgent, AgentState
from ..middleware.budget_controller import check_budget_before_api_call

logger = logging.getLogger(__name__)


class ICPBuilderAgent(BaseAgent):
    """
    Stage 3 Agent: Build Ideal Customer Profiles (ICPs)
    - Analyzes context and JTBD to identify customer segments
    - Extracts traits (industry, size, tech stack, etc.)
    - Identifies pain points from context clues
    - Infers behaviors and motivations
    - Generates ICP cards with confidence scores and avatars
    """

    def __init__(self):
        super().__init__(
            name="ICPBuilder",
            description="Generates Ideal Customer Profiles from context and jobs"
        )
        self.services = ServiceManager()

    async def _process(self, state: AgentState) -> AgentState:
        """Build ICPs from context and JTBD"""
        try:
            state["stage"] = "building_icps"

            workspace_id = state["context"].get("workspace_id")
            context_items = state["context"].get("processed_context_items", [])
            jtbds = state["context"].get("extracted_jtbds", [])

            if not context_items:
                state["error"] = "No context items provided for ICP building"
                return state

            # Check budget
            if not check_budget_before_api_call("icp_building"):
                state["error"] = "Budget limit reached for ICP building"
                return state

            # Extract customer segments from context
            customer_segments = await self._identify_customer_segments(context_items, jtbds)

            logger.info(f"Identified {len(customer_segments)} customer segments")

            # Build ICP for each segment
            built_icps = []

            for segment in customer_segments:
                logger.info(f"Building ICP for segment: {segment.get('name')}")

                # Check budget
                if not check_budget_before_api_call("icp_generation"):
                    state["error"] = "Budget limit reached for ICP generation"
                    return state

                # Extract traits, pain points, behaviors
                icp_details = await self._extract_icp_details(segment, context_items)

                if icp_details:
                    icp = {
                        "id": str(uuid.uuid4()),
                        "workspace_id": workspace_id,
                        "name": segment.get("name"),
                        "traits": icp_details.get("traits", {}),
                        "pain_points": icp_details.get("pain_points", []),
                        "behaviors": icp_details.get("behaviors", []),
                        "confidence_score": icp_details.get("confidence_score", 0.8),
                        "evidence_citations": segment.get("evidence_citations", []),
                        "avatar_url": None,  # To be generated by user
                        "avatar_color": self._generate_avatar_color(segment),
                        "avatar_type": "icon",
                        "health_score": 0.5,  # Will be updated based on receipts
                        "mood": "neutral",
                        "created_at": datetime.utcnow().isoformat(),
                    }

                    built_icps.append(icp)

            state["results"]["built_icps"] = built_icps
            state["results"]["icp_count"] = len(built_icps)

            logger.info(f"Successfully built {len(built_icps)} ICPs")

        except Exception as e:
            logger.exception(f"Error in ICP building: {str(e)}")
            state["error"] = str(e)

        return state

    async def _identify_customer_segments(
        self,
        context_items: List[Dict[str, Any]],
        jtbds: List[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Identify distinct customer segments from context"""
        try:
            llm = self.services.llm

            # Combine context summaries
            context_summary = "\n---\n".join([
                f"Topics: {', '.join(item.get('topics', [])[:3])}\n"
                f"Text: {item.get('extracted_text', '')[:300]}"
                for item in context_items[:5]  # Use top 5 items
            ])

            jtbd_summary = "\n---\n".join([
                f"Why: {jtbd.get('why')}\n"
                f"Circumstances: {jtbd.get('circumstances')}"
                for jtbd in jtbds[:3]  # Use top 3 JTBD
            ])

            prompt = f"""Analyze this context and jobs to identify distinct customer segments.

Context Summary:
{context_summary}

Jobs-to-be-Done:
{jtbd_summary}

Identify 2-4 distinct customer segments based on the context. Return JSON array:
[{{
  "name": "Segment Name (e.g., 'Enterprise Startups' or 'Mid-market SaaS')",
  "characteristics": "1-2 sentence description",
  "size_estimate": "Company size/profile",
  "motivation": "Why this segment needs this",
  "relevance_score": 0.9
}}]

Return ONLY valid JSON array."""

            response = await llm.invoke(prompt)
            segments = json.loads(response)

            # Add evidence citations
            for segment in segments:
                segment["evidence_citations"] = [item["id"] for item in context_items[:3]]

            return segments

        except json.JSONDecodeError:
            logger.warning("Failed to parse segments response as JSON")
            return []
        except Exception as e:
            logger.error(f"Segment identification error: {str(e)}")
            return []

    async def _extract_icp_details(
        self,
        segment: Dict[str, Any],
        context_items: List[Dict[str, Any]]
    ) -> Optional[Dict[str, Any]]:
        """Extract detailed ICP information for a segment"""
        try:
            llm = self.services.llm

            # Combine relevant context
            context_text = "\n---\n".join([
                item.get("extracted_text", "")[:300]
                for item in context_items[:3]
            ])

            prompt = f"""Create a detailed Ideal Customer Profile for this segment:

Segment: {segment.get('name')}
Characteristics: {segment.get('characteristics')}
Size: {segment.get('size_estimate')}

Context:
{context_text}

Generate ICP details in JSON format:
{{
  "traits": {{
    "industry": "primary industry",
    "company_size": "typical company size",
    "location": "geographic focus",
    "tech_stack": "common technologies they use",
    "budget": "typical budget range",
    "decision_makers": "who makes decisions"
  }},
  "pain_points": [
    "pain point 1",
    "pain point 2",
    "pain point 3"
  ],
  "behaviors": [
    "behavior 1",
    "behavior 2",
    "behavior 3"
  ],
  "confidence_score": 0.85
}}

Return ONLY valid JSON."""

            response = await llm.invoke(prompt)
            icp_details = json.loads(response)

            return icp_details

        except json.JSONDecodeError:
            logger.warning("Failed to parse ICP details as JSON")
            return None
        except Exception as e:
            logger.error(f"ICP details extraction error: {str(e)}")
            return None

    def _generate_avatar_color(self, segment: Dict[str, Any]) -> str:
        """Generate a consistent color for avatar based on segment name"""
        colors = [
            "#A68763",  # Barleycorn
            "#D7C9AE",  # Akaroa
            "#2D2D2D",  # Mineshaft
            "#EAE0D2",  # White Rock
            "#8B7355",  # Brown variant
            "#D4A574",  # Gold variant
        ]

        # Use hash of segment name to select color consistently
        segment_name = segment.get("name", "")
        color_idx = sum(ord(c) for c in segment_name) % len(colors)
        return colors[color_idx]

    async def _validate(self, state: AgentState) -> AgentState:
        """Validate built ICPs"""
        try:
            state["stage"] = "validating_icps"

            built_icps = state["results"].get("built_icps", [])

            if not built_icps:
                logger.warning("No ICPs were built")
                state["status"] = "completed"
                return state

            # Validate each ICP has required fields
            required_fields = ["name", "traits", "pain_points", "behaviors"]
            valid_count = 0

            for icp in built_icps:
                if all(field in icp for field in required_fields):
                    valid_count += 1
                else:
                    logger.warning(f"ICP {icp.get('id')} missing required fields")

            logger.info(f"Validated {valid_count}/{len(built_icps)} ICPs")

            state["status"] = "completed"

        except Exception as e:
            logger.exception(f"Validation error: {str(e)}")
            state["error"] = str(e)

        return state

    async def _finalize(self, state: AgentState) -> AgentState:
        """Finalize ICP building results"""
        state["stage"] = "finalized"

        icp_count = state["results"].get("icp_count", 0)
        logger.info(f"ICP Building finalized with {icp_count} profiles")

        return state


# Factory function
def create_icp_builder_agent() -> ICPBuilderAgent:
    """Create a new ICPBuilderAgent instance"""
    return ICPBuilderAgent()
